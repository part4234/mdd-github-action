/*
 * generated by Xtext 2.20.0
 */
package uk.ac.kcl.inf.mdd.project.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import uk.ac.kcl.inf.mdd.project.githubaction.Repository;
import uk.ac.kcl.inf.mdd.project.githubaction.Workflow;
import uk.ac.kcl.inf.mdd.project.githubaction.Event;
import uk.ac.kcl.inf.mdd.project.githubaction.Job;
import uk.ac.kcl.inf.mdd.project.githubaction.Step;

import uk.ac.kcl.inf.mdd.project.githubaction.*; import org.eclipse.emf.common.util.EList

//says deprecated but works :o

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class GithubactionGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {

		val model = resource.contents.head as Repository
		fsa.generateFile(resource.deriveStatsTargetFileNameFor, model.doGenerateStats ) //-- To be added later for file generation
		
		
		//val className = resource.deriveClassNameFor
		
		fsa.generateFile('githubaction.yaml', model.doGenerateClass())
		
		//split file using the link shown
		
		}
	
	
	def deriveStatsTargetFileNameFor(Resource resource) {
		resource.URI.appendFileExtension('txt').lastSegment
	}
	

	def String doGenerateStats(Repository program) '''
		Program contains:
		
		- «program.eAllContents.filter(Repository).size» Repositories
		- «program.eAllContents.filter(Workflow).size» Workflows
		- «program.eAllContents.filter(Event).size» Events
		- «program.eAllContents.filter(Job).size» Jobs
		- «program.eAllContents.filter(Step).size» Steps

	'''
	
	def deriveClassNameFor(Resource resource) {
		val origName = resource.URI.lastSegment
		
		origName.substring(0, origName.indexOf('.')).toFirstUpper + 'Turtle'
	}
	
	/*
	 * Below are parseable dispatch mathos for all grammar types
	 */
	def String doGenerateClass(Repository program) '''
		«program.workflows.map[generateWorkflow(new Environment)].join('\n')»
	'''

	private static class Environment {
		var int counter = 0
		def getFreshVarName() '''i_«counter++»'''
		def exit() { counter-- }
	}
	
	def String generateWorkflow(Workflow workflow, Environment env) '''
		name: «workflow.name.toString»
		
		«IF !workflow.on.empty»
			on:
			
			«FOR event : workflow.on»

				«event.generateEvent»
			«ENDFOR»
		«ENDIF»
		«IF !workflow.jobs.empty»
			jobs:
			«FOR job : workflow.jobs»
				«generateJob(job)»
			«ENDFOR»
		«ENDIF»
	'''
	dispatch def String generateEvent(PushEvent event) '''
			push:
		«if (!event.branches.empty && event.branches.get(0) !== null){'''	branches: [«event.branches.get(0)»]'''}»
		«if (!event.tags.empty && event.tags.get(1) !== null){''' 	tags: «event.tags.get(0)»'''}»
		«if (!event.branchesIgnore.empty && event.branchesIgnore.get(1) !== null){''' 	branchesIgnore: «event.branchesIgnore.get(0)»'''}»
		«if (!event.tagsIgnore.empty && event.tagsIgnore.get(1) !== null){''' 	tagsIgnore: «event.tagsIgnore.get(0)»'''}»
		«if (!event.paths.empty && event.paths.get(1) !== null){''' 	paths: «event.paths.get(0)»'''}»
		«if (!event.pathsIgnore.empty && event.pathsIgnore.get(1) !== null){''' 	pathsIgnore: «event.pathsIgnore.get(0)»'''}»	
	'''
	dispatch def String generateEvent(PullRequestEvent event) '''
			pull:
		«if (!event.branches.empty && event.branches.get(0) !== null){'''	branches: [«event.branches.get(0)»]'''}» 
		«if (!event.tags.empty && event.tags.get(1) !== null){''' 	tags: «event.tags.get(0)»'''}»
		«if (!event.branchesIgnore.empty && event.branchesIgnore.get(1) !== null){''' 	branchesIgnore: «event.branchesIgnore.get(0)»'''}»
		«if (!event.tagsIgnore.empty && event.tagsIgnore.get(1) !== null){''' 	tagsIgnore: «event.tagsIgnore.get(0)»'''}»
		«if (!event.paths.empty && event.paths.get(1) !== null){''' 	paths: «event.paths.get(0)»'''}»
		«if (!event.pathsIgnore.empty && event.pathsIgnore.get(1)  !== null){''' 	pathsIgnore: «event.pathsIgnore.get(0)»'''}»	
	'''
	dispatch def String generateEvent(ScheduleEvent event) '''
			schedule:	
		«if (event.hour !== null){'''	 -cron: «event.minute» «event.hour» «event.day» «event.month» «event.dayOfWeek»'''}» 
		
	'''	
	dispatch def String generateEvent(WorkflowDispatchEvent event) '''
			workflow_dispatch:
		«if (event.inputs.get(0) !== null){'''	 inputs: «event.inputs.get(0)» «event.inputs.get(1)»'''}» 			

	'''
	dispatch def String generateEvent(RepositoryDispatchEvent event) '''
			repository_dispatch:
		«if (event.eventTypes.get(0) !== null){'''	 types: [«event.eventTypes.get(0)»,«event.eventTypes.get(1)»]'''}» 	
	'''	
	
	dispatch def String generateEvent(CreateEvent event) ''''''
	dispatch def String generateEvent(DeleteEvent event) ''''''
	dispatch def String generateEvent(DeploymentEvent event) ''''''	
	dispatch def String generateEvent(IssueEvent event) '''		
		«IF !event.activityTypes.empty»
			«FOR type : event.activityTypes»
				types: [«IssueActivityType(type)»]
			«ENDFOR»
		«ENDIF»
	'''	
	dispatch def String generateEvent(LabelEvent event) '''
		«IF !event.activityTypes.empty»
			«FOR type : event.activityTypes»
				types: [«labelActivityType(type)»]
			«ENDFOR»
		«ENDIF»	
	'''	
	dispatch def String IssueActivityType(IssueActivityType type) '''
		«IF type === IssueActivityType.OPENED» «IssueActivityType.OPENED», «ENDIF»
		«IF type === IssueActivityType.CLOSED» «IssueActivityType.CLOSED», «ENDIF»
		«IF type === IssueActivityType.DELETED» «IssueActivityType.DELETED» «ENDIF»
		«IF type === IssueActivityType.EDITED» «IssueActivityType.EDITED», «ENDIF»
		«IF type === IssueActivityType.DELETED» «IssueActivityType.DELETED», «ENDIF»
		«IF type === IssueActivityType.TRANSFERRED» «IssueActivityType.TRANSFERRED», «ENDIF»
		«IF type === IssueActivityType.ASSIGNED» «IssueActivityType.ASSIGNED», «ENDIF»
		«IF type === IssueActivityType.UNASSIGNED» «IssueActivityType.UNASSIGNED», «ENDIF»
		«IF type === IssueActivityType.LOCKED» «IssueActivityType.LOCKED», «ENDIF»
		«IF type === IssueActivityType.UNLOCKED» «IssueActivityType.UNLOCKED», «ENDIF»
		«IF type === IssueActivityType.REOPENED» «IssueActivityType.REOPENED» «ENDIF»
	'''	
	dispatch def String labelActivityType(LabelActivityType type) '''
		«IF type === LabelActivityType.CREATED»  «LabelActivityType.CREATED», «ENDIF»
		«IF type === LabelActivityType.EDITED» «LabelActivityType.EDITED», «ENDIF»
		«IF type === LabelActivityType.DELETED» «LabelActivityType.DELETED» «ENDIF»

	'''
	def String generateJob(Job job) '''
			«job.name»:
				name: «job.jobName.toString»
			runsOn: «job.runsOn.toString»
			«IF !job.needs.empty»needs: [«job.needs.get(0).toString.substring(147,152)»,«job.needs.get(1).toString.substring(147,152)»]«ENDIF»
			«IF !job.env.empty»	env:
				«FOR input : job.env»«input.name»: «input.value»«ENDFOR»«ENDIF»
		«IF !job.steps.empty»
				steps:
			«FOR step : job.steps»
				«generateStepsType(step)»
			«ENDFOR»	
		«ENDIF»						
	'''	

	def String generateStepsType(Step step) '''
		«IF step.stepName !== null»		- name: «step.stepName»«ENDIF»
		«IF step.stepName === null && step.uses !== null»		- uses: «step.uses.toString»
		«ELSEIF step.uses !== null»		uses: «step.uses.toString»«ENDIF»
		
		«IF !step.with.empty»		with:
			«FOR input : step.with»«input.name»:«input.value»«ENDFOR»
		«ENDIF»
		«IF !step.run.empty»		run:  «FOR line : step.run»«line»«ENDFOR» «ENDIF»
		«IF !step.env.empty»		env: «FOR input : step.env»«input.name»:«input.value»«ENDFOR»«ENDIF»
	'''	
}
