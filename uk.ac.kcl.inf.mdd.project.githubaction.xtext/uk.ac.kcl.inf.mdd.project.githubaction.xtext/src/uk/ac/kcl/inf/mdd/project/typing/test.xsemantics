import uk.ac.kcl.inf.szschaler.turtles.turtles.Addition
import uk.ac.kcl.inf.szschaler.turtles.turtles.Expression
import uk.ac.kcl.inf.szschaler.turtles.turtles.IntLiteral
import uk.ac.kcl.inf.szschaler.turtles.turtles.IntVarExpression
import uk.ac.kcl.inf.szschaler.turtles.turtles.LoopStatement
import uk.ac.kcl.inf.szschaler.turtles.turtles.MoveStatement
import uk.ac.kcl.inf.szschaler.turtles.turtles.Multiplication
import uk.ac.kcl.inf.szschaler.turtles.turtles.RealLiteral
import uk.ac.kcl.inf.szschaler.turtles.turtles.TurnStatement
import uk.ac.kcl.inf.szschaler.turtles.validation.AbstractTurtlesValidator

//give subexpressions and give the overall type and cached. =1
auxiliary {
	typeExpressions(Iterable<Expression> exps) : TurtlesType cached
}

//takes a judgements and return it, e.g. turtleType
// also caches it so doesnt have to recompute. = 3 and 6
judgments {
	type |- Expression exp : output TurtlesType
		cached
		error "cannot type " + stringRep(exp)
		// checks boolean validaiton of subtype
	subType |- TurtlesType left <: TurtlesType right
		error stringRep(left) + " is not a subtype of " + stringRep(right)
}

//how the type auxiliary is computed. =2
auxiliary typeExpressions(Iterable<Expression> exps) {
	if (exps.forall[exp | 
			empty |- exp : var TurtlesType exp2Type 
			exp2Type === TurtlesType.INT]) {
		return TurtlesType.INT			
	} else {
		return TurtlesType.REAL
	}
}


// Aximons takes a model element (as a whole) and returns type = 5
// e.g. regardless what g is, if is intliteral then exp type is defined int in enum
axiom TIntLit
	G |- IntLiteral exp : TurtlesType.INT
	
axiom TRealLit
	G |- RealLiteral exp : TurtlesType.REAL
	
axiom TVarRef
	G |- IntVarExpression exp : TurtlesType.INT


//calculates and returns the instance of type, returns a varaible t. =3
rule TMultiplication
	G |- Multiplication exp : TurtlesType t
from {
	t = (exp.right + #[exp.left]).typeExpressions
}

rule TAddition
	G |- Addition exp : TurtlesType t
from {
	t = (exp.right + #[exp.left]).typeExpressions
}

rule SubTyping
	G |- TurtlesType left <: TurtlesType right
from {
	right === TurtlesType.REAL or left === right
}

//checks the type of subexpressions and gives them a type. = 4
checkrule checkTurnStatement for 
	TurnStatement stmt
from {
	//whats the degrees, starting from exmpty context whts the type of this and then pass down degreesType
	empty |- stmt.degrees : var TurtlesType degreesType
	// above is checked , using subtyping by checking it is if it's a sub
	empty |- degreesType <: TurtlesType.REAL
}

checkrule checkMoveStatement for
	MoveStatement stmt
from {
	empty |- stmt.steps : var TurtlesType stepsType
	empty |- stepsType <: TurtlesType.INT
}


checkrule checkLoopStatement for
	LoopStatement stmt
from {
	empty |- stmt.count : var TurtlesType countType
	empty |- countType <: TurtlesType.INT
}

